<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
 <title>Vector data processing in GRASS GIS</title>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <meta name="Author" content="Markus Neteler/GRASS Development Team">
 <link rel="stylesheet" href="grassdocs.css" type="text/css">
</head>
<body bgcolor="white">

<img src="grass_logo.png" alt="_\|/_ GRASS logo"><hr align=center size=6 noshade>

<h2>Vector data processing in GRASS GIS</h2>

<h3>Vector import and export</h3>

The <a href="v.in.ogr.html">v.in.ogr</a> module offers a common
interface for many different vector formats. Additionally, it
offers options such as on-the-fly creation of new locations or extension of
the default region to match the extent of the imported vector map.
For special cases, other import modules are available, e.g.
<a href="v.in.ascii.html">v.in.ascii</a> for input from a text file 
containing coordinate and attribute data, and 
<a href="v.in.db.html">v.in.db</a> for input from a database containing 
coordinate and attribute data.

With <a href="v.external.html">v.external</a> external maps can be
virtually linked into a mapset, only pseudo-topology is generated but
the vector geometry is not imported.

The <em>v.out.*</em> set of commands exports to various formats.

<h3>Information</h3>

The <a href="v.info.html">v.info</a> display general information such
as metadata and attribute columns about a vector map including the
history how it was generated.

<h3>Vector map operations</h3>

GRASS vector map processing is always performed on the full map.
If this is not desired, the input map has to be clipped to the
current region beforehand (<a href="v.in.region.html">v.in.region</a>,
<a href="v.overlay.html">v.overlay</a>,<a href="v.select.html">v.select</a>).

<h3>Vector model and topology</h3>

GRASS is a topological GIS. This means that adjacent geographic
components in a single vector map are related. For example in a
non-topological GIS if two areas shared a common border that border
would be digitized two times and also stored in duplicate. In a
topological GIS this border exists once and is shared between two
areas.  Topological represenation of vector data helps to produce and
maintain vector maps with clean geometry as well as enables certain
analyses that can not be conducted with non-topological or spaghetti
data. In GRASS topological data are refered to as level 2 data and
spaghetti data is referred to as level 1.
<p>
Sometimes topology is not necessary and the additional memory and
space requirements are burdensome to a particular task. Therefore two
modules allow for working level 1 (non-topological) data within
GRASS. The <a href="v.in.ascii.html">v.in.ascii</a> module allows
users to input points without building topology. This is very useful
for large files where memory restrictions may cause difficulties. The
other module which works with level 1 data is 
<a href="v.surf.rst.html">v.surf.rst</a> which enables spatial
approximation and topographic analysis from a point or isoline file.

<p> In GRASS, the following vector object types are available:

<ul>
<li> <b>point:</b> a point</li>
<li> <b>line:</b> a sequence of vertices connected by line(s) with two endpoints
     called nodes</li>
<li> <b>boundary:</b> the border line of an area</li>
<li> <b>centroid:</b> the label point of an area</li>
<li> <b>area:</b> the topological composition of centroid and boundary</li>
<li> <b>face:</b> a 3D area</li>
<li> <b>kernel:</b> a 3D centroid in a volume (not yet implemented)</li>
<li> <b>volume:</b> a 3D corpus (not yet implemented)</li>
</ul>

The <a href="v.type.html">v.type</a> module can be used to convert
between vector types if possible. The <a href="v.build.html">v.build</a>
module is used to generate topology. It optionally allows to extract
the erroneous vector objects into a separate map. Topological errors
can be corrected either manually within <a href="v.digit.html">v.digit</a>
or, to some extent, automatically in <a href="v.clean.html">v.clean</a>.

Adjacent polygons can be found by <a href="v.to.db.html">v.to.db</a>
(see 'sides' option).

<h3>Attribute management</h3>

GRASS can be linked to one or many database management systems (DBMS).
The <em>db.*</em> set of commands provides basic SQL support for
attribute management, while the <em>v.db.*</em> set of commands operates
on the vector map.

<ul>
<li><b>Categories:</b> The category number is the vector ID. It is
used to link attribute(s) to each vector object. A vector object can
have zero, one, two, or more categories. The category number is stored
within the geometry file for each vector object. Using 
<a href="v.category.html">v.category</a> the category numbers can be
printed or maintained.</li>

<li><b>Layers:</b> It is possible to link the geographic objects in
one vector map to one or more tables. Each link to a distinct
attribute table is called a layer. GRASS layers do not contain any
geographic objects, but consist of links to attribute tables in which
vector objects can have zero or more categories. If a vector object
has zero categories in a layer, then it does not appear in that
layer. In this fasion some vector objects may appear in some layers
but not in others. The practical benefit of this system is that it
allows placement of thematically distinct but topologically related
objects in a single file (e.g. forests and lakes). These virtual
layers also are useful for linking time series attribute data to a
series of locations that did not change over time. By default the
first layer is active, i.e. the first table corresponds to the first
layer. Further tables are linked to subsequent layers.  Using
<a href="v.db.connect.html">v.db.connect</a> layers can be listed or
maintained.</li>

<li><b>SQL support:</b> The DBF driver provides only very limited SQL
support (as DBF is not an SQL DB) while the other DBMS backends (such
as PostgreSQL, MySQL etc) provide full SQL support since the SQL
commands are sent directly to the DBMI. SQL commands can be directly
executed with <a href="db.execute.html">db.execute</a>,
<a href="db.select.html">db.select</a> and the other db.* modules.
</li>
</ul>

When creating vector maps from scratch, in general an attribute table must be created and
the table must be populated with one row per category (using <a href="v.to.db.html">v.to.db</a>).
However, this can be performed in a single step using <a href="v.db.addtable.html">v.db.addtable</a>
along with the definition of table column types.

<h3>Editing vector attributes</h3>

To manually edit attributes of a table, the map has to be
queried in 'edit mode' using <a href="d.what.vect.html">d.what.vect</a>.
To bulk process attributes, it is recommended to use SQL
(<a href="db.execute.html">db.execute</a>).

<h3>Geometry operations</h3>

The module <a href="v.in.region.html">v.in.region</a> saves the
current region boundary into a vector area.

Split vector lines can be changes to polylines by
<a href="v.build.polylines.html">v.build.polylines</a>. Long lines can be
split by <a href="v.split.html">v.split</a> and
<a href="v.segment.html">v.segment</a>.

Buffer and circles can be generated with <a href="v.buffer.html">v.buffer</a>
and <a href="v.parallel.html">v.parallel</a>.

2D vector maps can be changed to 3D using
<a href="v.drape.html">v.drape</a> or <a href="v.extrude.html">v.extrude</a>.
If needed, the spatial position of vector points can be perturbed by
<a href="v.perturb.html">v.perturb</a>.

The <a href="v.type.html">v.type</a> command changes between vector
types (see list above). 

Projected vector maps can be reprojected with <a href="v.proj.html">v.proj</a>.
Unprojected maps can be geocoded with <a href="v.transform.html">v.transform</a>.

Triangulation and point-to-polygon conversions can be done with <a
href="v.delaunay.html">v.delaunay</a>, <a href="v.hull.html">v.hull</a>,
and <a href="v.voronoi.html">v.voronoi</a>.

The <a href="v.random.html">v.random</a> command generated random points.

<h3>Vector overlays and selections</h3>

Geometric overlay of vector maps is done with <a href="v.patch.html">v.patch</a>,
<a href="v.overlay.html">v.overlay</a> and <a href="v.select.html">v.select</a>,
depending on the combination of vector types.

Vectors can be extracted with <a href="v.extract.html">v.extract</a>
and reclassified with <a href="v.reclass.html">v.reclass</a>.


<h3>Vector statistics</h3>

Statistics can be generated by <a href="v.qcount.html">v.qcount</a>,
<a href="v.sample.html">v.sample</a>, <a href="v.normal.html">v.normal</a>,
and <a href="v.univar.html">v.univar</a>.

Distances between vector objects are calculated with <a href="v.distance.html">v.distance</a>.

<h3>Vector-Raster-DB conversion</h3>

The <a href="v.to.db.html">v.to.db</a> transfers vector information
into database tables.

With <a href="v.to.points.html">v.to.points</a>,
<a href="v.to.rast.html">v.to.rast</a> and <a href="v.to.rast3.html">v.to.rast3</a>
conversions are performed.

<h3>Vector queries</h3>

Vector maps can be queried with <a href="v.what.html">v.what</a> and
<a href="v.what.vect.html">v.what.vect</a>.

<h3>Vector-Raster queries</h3>

Raster values can be transferred to vector maps with 
 <a href="v.what.rast.html">v.what.rast</a> and
<a href="v.rast.stats">v.rast.stats</a>.

<h3>Vector network analysis</h3>

GRASS provides support for vector network analysis. The following algorithms
are implemented:

<ul>
<li> Vector maintenance: <a href="v.net.html">v.net</a></li>
<li> Shortest path: <a href="d.path.html">d.path</a> and 
     <a href="v.net.path.html">v.net.path</a></li>
<li> Traveling salesman (round trip): <a href="v.net.salesman.html">v.net.salesman</a></li>
<li> Allocation of sources (create subnetworks, e.g. police station zones):
     <a href="v.net.alloc.html">v.net.alloc</a></li>
<li> Minimum Steiner trees (star-like connections, e.g. broadband cable 
     connections): <a href="v.net.steiner.html">v.net.steiner</a></li>
<li> Iso-distances (from centers): <a href="v.net.iso.html">v.net.iso</a></li>
</ul>

Vector directions are defined by the digitizing direction (a--&gt;--b).
Both directions are supported, network modules provide parameters
to assign attribute columns to the forward and backward direction.

<h3>Vector networks: Linear reference system (LRS)</h3>

LRS uses linear features and distance measured along those features to
positionate objects. There are the commands
<a href="v.lrs.create.html">v.lrs.create</a> to create a linear reference system,
<a href="v.lrs.label.html">v.lrs.label</a> to create stationing on the LRS, 
<a href="v.lrs.segment.html">v.lrs.segment</a> to create points/segments on LRS,
 and
<a href="v.lrs.where.html">v.lrs.where</a> to find line id and real km+offset 
for given points in vector map using linear reference system.
<p>
The <a href="lrs.html">LRS tutorial</a> explains further details.


<h3>Interpolation and approximation</h3>

Some of the vector modules deal with spatial or volumetric
approximation (also called interpolation):
<a href="v.kernel.html">v.kernel</a>,
<a href="v.surf.idw.html">v.surf.idw</a>,
<a href="v.surf.rst.html">v.surf.rst</a>, and
<a href="v.vol.rst.html">v.vol.rst</a>.


<h3>Lidar data processing</h3>

Lidar point clouds (first and last ping) are imported with <a
href="v.in.ascii.html">v.in.ascii</a> (-b flag to not build the
topology). Outlier detection is done with 
<a href="v.outlier.html">v.outlier</a> on both first and last ping data.
Then, with <a href="v.lidar.edgedetection.html">v.lidar.edgedetection</a>,
edges are detected from last ping data. The building are generated by
<a href="v.lidar.growing.html">v.lidar.growing</a> from detected
edges.  The resulting data are post-processed with
<a href="v.lidar.correction.html">v.lidar.correction</a>. Finally, the
DTM and DSM are generated with <a href="v.surf.bspline.html">v.surf.bspline</a>
(DTM: uses the 'v.lidar.correction' output; DSM: uses last ping output
from outlier detection).

<h3>See also</h3>

<ul>
<li><a href="databaseintro.html">Introduction to GRASS database management</a></li>
<li><a href="rasterintro.html">Introduction to GRASS raster map processing</a></li>
<li><a href="raster3dintro.html">Introduction to GRASS 3D raster map (voxel) processing</a></li>
</ul>

<HR>
<BR>
<a href="index.html">Main index</a> - <a href="vector.html">vector index</a> - <a href="full_index.html">full index</a>
</body>
</html>
