#!/bin/sh

############################################################################
#
# MODULE:       g.extension
# AUTHOR(S):   	Markus Neteler
# PURPOSE:      Tool to download and install extensions from GRASS Addons SVN into 
#               local GRASS installation
# COPYRIGHT:    (C) 2009-2010 by the Markus Neteler, GRASS Development Team
#
#               This program is free software under the GNU General Public
#               License (>=v2). Read the file COPYING that comes with GRASS
#               for details.
#
#############################################################################


#%Module
#% label: Tool to maintain GRASS extensions in local GRASS installation.
#% description: Downloads, installs extensions from GRASS Addons SVN repository into local GRASS installation or removes installed extensions.
#% keywords: general, extensions
#%End

#%option
#% key: extension
#% type: string
#% key_desc: name
#% description: Name of extension to install/remove
#% required: no
#%end
#%option
#% key: operation
#% type: string
#% key_desc: name
#% description: Operation to be performed
#% required: no
#% options: add,remove
#% answer: add
#%end
#%option
#% key: svnurl
#% type: string
#% key_desc: url
#% description: SVN Addons repository URL
#% required: yes
#% answer: https://svn.osgeo.org/grass/grass-addons/
#%end
#%option
#% key: prefix
#% type: string
#% key_desc: path
#% description: Prefix where to install extension
#% answer: $GRASS_ADDON_PATH
#% required: yes
#%end
#%flag
#% key: l
#% description: List available modules in the GRASS Addons SVN repository
#% guisection: Print
#%end


if  [ -z "$GISBASE" ] ; then
    echo "You must be in GRASS GIS to run this program." >&2
    exit 1
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
  exec g.parser "$0" "$@"
fi

# definitions

SVNURL_ADDONS=${GIS_OPT_SVNURL}
MODULE="$GIS_OPT_EXTENSION"
PREFIX="$GIS_OPT_PREFIX"

#make a temporary directory
TMPDIR="`g.tempfile pid=$$`"
if [ $? -ne 0 ] || [ -z "$TMPDIR" ] ; then
    g.message -e "Unable to create temporary files"
    exit 1
fi
rm -f "$TMPDIR"
mkdir "$TMPDIR"

# check if we have the svn client
if [ ! -x "`which svn`" ] ; then
    g.message -e "svn client required. Please install Subversion first."
    exit 1
fi

# check if we have the make program
if [ ! -x "`which make`" ] ; then
    g.message -e "'make' program required. Please install first."
    exit 1
fi

# check if we have wget or curl
if [ ! -x "`which wget`" ] ; then
    if [ ! -x "`which curl`" ] ; then
        g.message -e "Either 'wget' or 'curl' is required, please install one first"
        exit 1
    else
        g.message -v "Using CURL for downloading data."
        USE_CURL=1
    fi
else
    g.message -v "Using WGET for downloading data."
    USE_WGET=1
fi

expand_module_class_name()
{
# $1: module class
 if [ "$1" = "d" ]  ; then 
    echo "display"  
  elif [ "$1" = "db" ] ; then 
    echo "database" 
  elif [ "$1" = "g" ]  ; then 
    echo "general" 
  elif [ "$1" = "i" ]  ; then 
    echo "imagery" 
  elif [ "$1" = "m" ]  ; then 
    echo "misc" 
  elif [ "$1" = "ps" ] ; then 
    echo "postscript" 
#  elif [ "$1" = "p" ]  ; then 
#    echo "paint" 
  elif [ "$1" = "r" ]  ; then 
    echo "raster" 
  elif [ "$1" = "r3" ]  ; then 
    echo "raster3D" 
#  elif [ "$1" = "s" ]  ; then 
#    echo "sites" 
  elif [ "$1" = "v" ]  ; then 
    echo "vector"
  else 
    echo "$1"
 fi
}

if [ `echo "$MODULE" | grep -c '/'` -eq 0 ] ; then
   CLASSCHAR=`echo $MODULE | cut -d'.' -f1`
   MODULECLASS=`expand_module_class_name $CLASSCHAR`
else
   # handle vector/adehabitat/ or just vector/v.module ...
   TOPLEVEL=`echo $MODULE | cut -d'/' -f1`
   MODULECLASS="$TOPLEVEL"
   MODULE=`echo "$MODULE" | sed -e "s+^$MODULECLASS/++"`
fi


list_available_modules()
{
 # a very dirty hack
 g.message message="Fetching list of modules from GRASS-Addons SVN (be patient)..."
 for d in d db g i m ps p r r3 v ; do
     MODCLASS=`expand_module_class_name $d`
     cd "$TMPDIR"
     rm -f index.html
     if [ "$USE_WGET" ] ; then
        wget --quiet -nv "$SVNURL_ADDONS/$MODCLASS"
     else
        curl -silent --location "$SVNURL_ADDONS/$MODCLASS" -o index.html
     fi
     grep '<li>' index.html 2> /dev/null | grep -v '\.\.' | \
        cut -d'"' -f2 | sed 's+/$++g' >> list_$$.txt
     rm -f index.html
 done
 cat list_$$.txt
 rm -f list_$$.txt
 # so why save to a file at all instead of cat'ing directly?
}

##
cleanup(){
 if  [ ! -z "${TMPDIR}" ] ; then
     rm -rf "${TMPDIR}"
 fi
}

if [ $GIS_FLAG_L -eq 1 ] ; then
   list_available_modules
   rmdir "$TMPDIR"
   exit 0
fi

if [ -z "$GIS_OPT_EXTENSION" -a $GIS_FLAG_L -eq 0 ] ; then
   g.message message="You need to define an extension name or use -l"
   exit 1
fi

if [ "$PREFIX" == '$GRASS_ADDON_PATH' ] ; then
    if [ -z "$GRASS_ADDON_PATH" ] ; then
        g.message -e "GRASS_ADDON_PATH is not defined"
        exit 1
    fi
    PREFIX=$GRASS_ADDON_PATH
fi

if [ -d "$PREFIX" ] ; then
    MYINST_DIR="$PREFIX"
else
    g.message -e "'$PREFIX' does not exist"
    exit 1
fi

if [ "$GIS_OPT_OPERATION" == "remove" ] ; then
   g.message message="Removing <$MODULE>..."
   
   if test -f "${MYINST_DIR}/bin/${MODULE}" ; then
       rm -f "${MYINST_DIR}/bin/${MODULE}"
   fi
   if test -f "${MYINST_DIR}/docs/html/${MODULE}.html" ; then
       rm -f "${MYINST_DIR}/docs/html/${MODULE}.html"
   fi
   if test -f "${MYINST_DIR}/man/man1/${MODULE}.1" ; then
       rm -f "${MYINST_DIR}/man/man1/${MODULE}.1"
   fi

   exit 0
fi

g.message -d "svn co [$SVNURL_ADDONS]/[$MODULECLASS]/[$MODULE]"

cd "$TMPDIR"
g.message message="Fetching <$MODULE> from GRASS-Addons SVN (be patient)..."
svn co ${SVNURL_ADDONS}/${MODULECLASS}/${MODULE}

if [ $? -ne 0 ] ; then
   g.message -e message="GRASS Addon ${MODULE} not found in repository or no network connection or another problem"
   exit 1
fi

cd "$TMPDIR/$MODULE"
g.message message="Compiling <${MODULE}>..."
make MODULE_TOPDIR="$GISBASE"
if [ $? -ne 0 ] ; then
   g.message -e message="Compilation failed, sorry. Please check above error messages."
   cleanup
   exit 1
else
   g.message message="Installing ${MODULE}..."
   # can we write? Install dir present?
   if test ! -d "${MYINST_DIR}" ; then
      mkdir -p "${MYINST_DIR}"
   fi
   if test ! -d "${MYINST_DIR}/bin" ; then
      mkdir -p "${MYINST_DIR}/bin"
   fi
   if test ! -d "${MYINST_DIR}/docs/html" ; then
      mkdir -p "${MYINST_DIR}/docs/html"
   fi
   if test ! -d "${MYINST_DIR}/man/man1" ; then
      mkdir -p "${MYINST_DIR}/man/man1"
   fi
   touch "${MYINST_DIR}/`basename $0`.$$"
   if [ $? -ne 0 ] ; then
      g.message -e message="Cannot write to <${MYINST_DIR}>, installation failed"
      exit 1
   else
      rm -f "${MYINST_DIR}/`basename $0`.$$"
      if test -f "${MYINST_DIR}/bin/${MODULE}" ; then
         rm -f "${MYINST_DIR}/bin/${MODULE}"
      fi
      make MODULE_TOPDIR="$GISBASE" INST_DIR="$MYINST_DIR" install
      if [ $? -ne 0 ] ; then
         g.message -e message="Installation failed, sorry. Please check above error messages."
         cleanup
         exit 1
      fi
      if [ ! -x "${MYINST_DIR}/bin/${MODULE}" ] ; then
	g.message -e "Module did not install properly"
	cleanup
	exit 1
      fi
   fi
fi

cleanup

g.message message=""
g.message message="Installation of <$MODULE> in <$MYINST_DIR> successfully finished."
exit 0
