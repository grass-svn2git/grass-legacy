#!/bin/sh

#import of SRTM hgt files into GRASS
# written by Markus Neteler 11/2003 neteler AT itc it
#
# COPYRIGHT:	(C) 2004 by the GRASS Development Team
#
#		This program is free software under the GNU General Public
#		License (>=v2). Read the file COPYING that comes with GRASS
#		for details.
#
# Dec 2004: merged with srtm_generate_hdr.sh (M. Neteler)
#           corrections and refinement (W. Kyngesburye)
# Aug 2004: modified to accept files from other directories
#           (by H. Bowman)
# June 2005: added flag to read in US 1-arcsec tiles (H. Bowman)
#
#########################
#Derived from:
# ftp://e0dps01u.ecs.nasa.gov/srtm/Documentation/Notes_for_ARCInfo_users.txt
#     (bugfix: the USGS document was updated silently end of 2003)
#
# ftp://e0dps01u.ecs.nasa.gov/srtm/Documentation/SRTM_Topo.txt
#  "3.0 Data Formats
#  [...]
#  To be more exact, these coordinates refer to the geometric center of 
#  the lower left pixel, which in the case of SRTM-1 data will be about
#  30 meters in extent."
#
#- SRTM 90 Tiles are 1 degree by 1 degree
#- SRTM filename coordinates are said to be the *center* of the LL pixel.
#       N51E10 -> lower left cell center
#
#- BIL uses *center* of the UL (!) pixel:
#      http://downloads.esri.com/support/whitepapers/other_/eximgav.pdf
#  
#- GDAL uses *corners* of pixels for its coordinates.
#
# NOTE: Even, if small difference: SRTM is referenced to EGM96, not WGS84 ellps
# http://earth-info.nga.mil/GandG/wgsegm/egm96.html
#
#########################

#%Module
#% description: Import SRTM HGT files into GRASS
#%End
#%option
#% key: input
#% gisprompt: file,file,file
#% type: string
#% description: SRTM input tile (file without .hgt.zip extension)
#% required : yes
#%end
#%option
#% key: output
#% gisprompt: new,cell,raster
#% type: string
#% description: Output raster map (default: input tile)
#% required : no
#%end
#%flag
#%  key: 1
#%  description: Input is a 1-arcsec tile (default: 3-arcsec)
#%end


# what to do in case of user break:
exitprocedure()
{
 echo "User break!"
 exit 1
}
trap "exitprocedure" 2 3 15

if test "$GISBASE" = ""; then
 echo "You must be in GRASS GIS to run this program." >&2
 exit 1
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
  exec g.parser "$0" "$@"
fi

#### check if we have awk
if [ ! -x "`which awk`" ] ; then
    echo "$PROG: awk required, please install awk or gawk first" 2>&1
    exit 1
fi

# setting environment, so that awk works properly in all languages
unset LC_ALL
export LC_NUMERIC=C

eval `g.gisenv`
: ${GISBASE?} ${GISDBASE?} ${LOCATION_NAME?} ${MAPSET?}
LOCATION=$GISDBASE/$LOCATION_NAME/$MAPSET
PERM=$GISDBASE/$LOCATION_NAME/PERMANENT

grep -i 'proj: ll' $PERM/PROJ_INFO > /dev/null
if [ $? -ne 0 ] ; then
 echo "SRTM data are in Latitude/Longitude. The current"
 echo "location projection differs. STOP."
 exit 1
fi

# use these from now on:
FILE=`echo $GIS_OPT_input | sed 's+.hgt++g'| sed 's+.zip++g'`
TILE=`echo "$FILE" | sed 's+^.*/++'`
FDIR=`echo "$FILE" | sed 's+[^/]*$++'`

if [ -z "$GIS_OPT_output" ] ; then
  TILEOUT=$TILE
else
  TILEOUT=$GIS_OPT_output
fi

if test ! -f $FILE.hgt.zip ; then
 echo "File '$FILE.hgt.zip' not found"
 exit 1
fi

ls -1 "$FILE.hgt.zip" | grep zip > /dev/null
if [ $? -ne 0 ] ; then
  echo "$FILE.hgt.zip is no zip file."
  exit 1
fi


#make a temporary directory
TMPDIR="`g.tempfile pid=$$`"
if [ $? -ne 0 ] || [ -z "$TMPDIR" ] ; then
    echo "ERROR: unable to create temporary files" 1>&2
    exit 1
fi
rm -f "$TMPDIR"
mkdir "$TMPDIR"

install -m 644 $FILE.hgt.zip "$TMPDIR"

#change to temporary directory
cd "$TMPDIR"

#unzip & rename data file:
echo "Extracting $FILE..."
unzip $FILE.hgt.zip
if [ $? -gt 0 ] ; then
 echo "An ERROR occurred."
 exit 1
fi

echo "Converting input file to BIL..."
mv $TILE.hgt "$TMPDIR"/$TILE.bil

LL_LATITUDE=`echo $TILE  | cut -b2-3`
LL_LONGITUDE=`echo $TILE | cut -b5-7`

#are we on the southern hemisphere? If yes, make LATITUDE negative.
NORTH=`echo $TILE  | sed 's+.hgt++g' | cut -b1`
if [ "$NORTH" = "S" ] ; then
   LL_LATITUDE=`echo $LL_LATITUDE | awk '{printf "%.10f", $1 * -1 }'`
fi

#are we west of Greenwich? If yes, make LONGITUDE negative.
EAST=`echo $TILE  | sed 's+.hgt++g' | cut -b4`
if [ "$EAST" = "W" ] ; then
   LL_LONGITUDE=`echo $LL_LONGITUDE | awk '{printf "%.10f", $1 * -1 }'`
fi

# Calculate Upper Left from Lower Left
ULXMAP=`echo $LL_LONGITUDE | awk '{printf "%.1f", $1}'`
# SRTM90 tile size is 1 deg:
ULYMAP=`echo $LL_LATITUDE  | awk '{printf "%.1f", $1 + 1.0}'`


if [ $GIS_FLAG_1 -ne 1 ] ; then
  echo "BYTEORDER M
LAYOUT BIL
NROWS 1201
NCOLS 1201
NBANDS 1
NBITS 16
BANDROWBYTES 2402
TOTALROWBYTES 2402
BANDGAPBYTES 0
NODATA -32768
ULXMAP $ULXMAP
ULYMAP $ULYMAP
XDIM 0.000833333333333
YDIM 0.000833333333333"> $TILE.hdr
else
  echo "Attempting to import 1-arcsec data."
  echo "BYTEORDER M
LAYOUT BIL
NROWS 3601
NCOLS 3601
NBANDS 1
NBITS 16
BANDROWBYTES 7202
TOTALROWBYTES 7202
BANDGAPBYTES 0
NODATA -32768
ULXMAP $ULXMAP
ULYMAP $ULYMAP
XDIM 0.000277777777777778
YDIM 0.000277777777777778"> $TILE.hdr
fi

#create prj file: To be precise, we would need EGS96! But who really cares...
echo "GEOGCS["wgs84",DATUM["WGS_1984",SPHEROID["wgs84",6378137,298.257223563],TOWGS84[0.000000,0.000000,0.000000]],PRIMEM["Greenwich",0],UNIT["degree",0.0174532925199433]]" > $TILE.prj

r.in.gdal in=$TILE.bil out=$TILEOUT

rm $TILE.bil $TILE.hdr $TILE.prj $TILE.hgt.zip
cd ..
rmdir "$TMPDIR"

#nice color table #and zoom to tile
r.colors rul=srtm map=$TILEOUT
#g.region rast=$TILEOUT

echo "Done: generated map $TILEOUT"
echo "(Note: Holes in the data can be closed with 'r.fillnulls' using splines)"
