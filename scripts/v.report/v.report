#!/bin/sh
#
############################################################################
#
# MODULE:	v.report
# AUTHOR(S):	Markus Neteler
# PURPOSE:	Reports geometry statistics for vector maps
# COPYRIGHT:	(C) 2005, 2007 by the GRASS Development Team
#
#		This program is free software under the GNU General Public
#		License (>=v2). Read the file COPYING that comes with GRASS
#		for details.
#
#############################################################################

#%Module
#%  description: Reports geometry statistics for vectors.
#%  keywords: vector, report, statistics
#%End
#%option
#% key: map
#% type: string
#% gisprompt: old,vector,vector
#% description: Name of input vector map
#% required: yes
#%end
#%option
#% key: layer
#% type: integer
#% answer: 1
#% description: Layer number
#% required: no
#%end
#%option
#% key: option
#% type: string
#% description: Value to calculate
#% options: area,length,coor
#% required: yes
#%end
#%option
#% key: units
#% type: string
#% description: mi(les),f(eet),me(ters),k(ilometers),a(cres),h(ectares)
#% options: mi,miles,f,feet,me,meters,k,kilometers,a,acres,h,hectares
#% required: no
#%end

# called from Grass?
if  [ -z "$GISBASE" ] ; then
 echo "You must be in GRASS GIS to run this program." >&2
 exit 1
fi   

if [ "$1" != "@ARGS_PARSED@" ] ; then
  exec g.parser "$0" "$@"
fi

# check if we have awk
if [ ! -x "`which awk`" ] ; then
    echo "ERROR: awk required. Please install awk or gawk first." 1>&2
    exit 1
fi

### setup enviro vars ###
eval `g.gisenv`
: ${GISBASE?} ${GISDBASE?} ${LOCATION_NAME?} ${MAPSET?}
LOCATION=$GISDBASE/$LOCATION_NAME/$MAPSET

### trap <ctrl>-<c> so that we can clean up tmp and exit
trap 'rm -f "$TMP1" "$TMP2" ; exit 1' 2 3 15

### secure temporary files:
TMP1="`g.tempfile pid=$$`"
TMP2="`g.tempfile pid=$$`"

MAP=$GIS_OPT_MAP
OPTION=$GIS_OPT_OPTION
LAYER=$GIS_OPT_LAYER

# does the input vector map exist?
eval `g.findfile element=vector file=$GIS_OPT_MAP`
if [ ! "$file" ] ; then
   echo "ERROR: Vector map '$MAP' not found in mapset search path." 1>&2
   exit 1
fi

#test if the input vector has a table attached in the given layer
v.info -c map=$MAP layer=$LAYER >/dev/null 2>&1
TABLEEXISTS_T1=$?
v.info -c map=$MAP layer=$LAYER 2>&1 | head -n1 | grep -v $MAP >/dev/null 2>&1
TABLEEXISTS_T2=$?
if [ $TABLEEXISTS_T1 -eq 1 ] || [ $TABLEEXISTS_T2 -eq 1 ] ; then
 TABLEEXISTS=0
else
 TABLEEXISTS=1
fi

#The above head+grep test is necessary because v.info -c in 6.2 CVS as of
#14.09.2006 does not exit with status '1' if no database connection is present.
#In 6.3 CVS this issue is fixed. 

#fetch column names
if [ $TABLEEXISTS -eq 1 ] ; then
 COLNAMES="`v.info -c map=$MAP layer=$LAYER | grep -v '^Displaying column type' | cut -d '|' -f2 | tr '\n' '|'`" >/dev/null 2>&1
else
 COLNAMES="cat|"
fi

#special treatment for opt=coor parameter:
if [ "$GIS_OPT_OPTION" = "coor" ] ; then
  COLUMS="dummy1,dummy2,dummy3"
  EXTRACOLNAMES="x|y|z"
else
  COLUMS="dummy1"
  EXTRACOLNAMES="$OPTION"
fi

#check for optional units parameter:
if [ ! -z $GIS_OPT_UNITS ] ; then
   UNITSPARAM="units=$GIS_OPT_UNITS"
fi   

## NOTE: we suppress -1 cat and 0 cat

if [ $TABLEEXISTS -eq 1 ] ; then
   v.db.select -c map=$MAP layer=$LAYER | sort -n -t'|' -k 1 | grep -v '^0' > "$TMP1"
   if [ `wc -l "$TMP1" | awk '{print $1}'` -eq 0 ] ; then
      KEY=`v.db.connect -g $GIS_OPT_MAP | cut -f3 -d" "`
      echo "ERROR: There is a table connected to input vector map '$MAP', but \
there are no categories present in the key column '$KEY'. Consider using \
v.to.db to correct this."
      exit 1
   fi
   #fetch the requested attribute sorted by cat:
   v.to.db -p map=$MAP opt=$OPTION col=$COLUMS $UNITSPARAM \
	   layer=$LAYER 2> /dev/null | grep -v '^cat' | grep -v '^-1' | grep -v '^0'\
	   | sort -n -t'|' -k 1 | cut -d'|' -f2-4 > "$TMP2"
   #make and print the table:
   echo "$COLNAMES$EXTRACOLNAMES"
   paste -d'|' "$TMP1" "$TMP2"
else
   #make and print the table:
   v.to.db -p map=$MAP opt=$OPTION col=$COLUMS $UNITSPARAM \
	   layer=$LAYER 2> /dev/null | grep -v '^-1' | grep -v '^0'\
	   | sort -n -t'|' -k 1
fi

#cleanup:
rm -f "$TMP1"
rm -f "$TMP2"

exit 0
