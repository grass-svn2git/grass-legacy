#!/bin/sh

############################################################################
#
# MODULE:	v.rast.stats
# AUTHOR(S):	Markus Neteler
# PURPOSE:	Calculates univariate statistics from a GRASS raster map
#		only for areas covered by vector objects on a per-category base
# COPYRIGHT:	(C) 2005 by the GRASS Development Team
#
#		This program is free software under the GNU General Public
#		License (>=v2). Read the file COPYING that comes with GRASS
#		for details.
#
#############################################################################

#%Module
#% description: Calculates univariate statistics from a GRASS raster map based on vector objects
#%End
#%flag
#%  key: c
#%  description: continue if upload column(s) already exist
#%END
#%option
#% key: vector
#% type: string
#% gisprompt: old,vector,vector
#% description: Name of vector polygon map
#% required : yes
#%End
#%option
#% key: raster
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of raster map to calculate statistics from
#% required : yes
#%END
#%option
#% key: colprefix
#% type: string
#% description: column prefix for new attribute columns
#% required : yes
#%end

if  [ -z $GISBASE ] ; then
    echo "You must be in GRASS GIS to run this program."
 exit 1
fi   

if [ "$1" != "@ARGS_PARSED@" ] ; then
  exec g.parser "$0" "$@"
fi

#### check if we have awk
if [ ! -x "`which awk`" ] ; then
    echo "$PROG: awk required, please install awk/gawk first" 2>&1
    exit 1
fi

# setting environment, so that awk works properly in all languages
unset LC_ALL
export LC_NUMERIC=C

TMPNAME=v_rast_stats.$$

cleanup()
{
 #restore settings:
 g.region region=${TMPNAME}
 g.remove region=${TMPNAME} > /dev/null
 g.remove rast=${VECTOR}_${TMPNAME} > /dev/null
 g.remove MASK > /dev/null 2> /dev/null
 if [ $MASKFOUND -eq 1 ] ; then
   echo "Restoring previous MASK..."
   g.rename ${TMPNAME}_origmask,MASK > /dev/null
 fi
}

# what to do in case of user break:
exitprocedure()
{
 echo "User break!"
 cleanup
 exit 1
}
# shell check for user break (signal list: trap -l)
trap "exitprocedure" 2 3 15


VECTOR="$GIS_OPT_vector"
RASTER="$GIS_OPT_raster"
COLPREFIX="$GIS_OPT_colprefix"

#check the input vector map
eval `g.findfile element=vector file=$VECTOR`
if [ ! "$file" ] ; then
  echo "Input vector map $VECTOR not found"
  exit 1
fi
#check the input raster map
eval `g.findfile element=cell file=$RASTER`
if [ ! "$file" ] ; then
  echo "Input raster map $RASTER not found"
  exit 1
fi

#check presence of raster MASK, put it aside
MASKFOUND=0
eval `g.findfile element=cell file=MASK`
if [ "$file" ] ; then
  echo "Raster MASK found, temporarily disabled"
  g.rename MASK,${TMPNAME}_origmask > /dev/null
  MASKFOUND=1
fi

#get RASTER resolution of map which we want to query:
#fetch separated to permit for non-square cells (latlong etc)
NSRES=`r.info -s $RASTER | grep nsres | cut -d'=' -f2`
if [ $? -ne 0 ] ; then
 echo "An error occurred reading the input raster map resolution."
 exit 1
fi
EWRES=`r.info -s $RASTER | grep ewres | cut -d'=' -f2`

#save current settings:
g.region save=${TMPNAME} > /dev/null

#Temporarily setting raster resolution to $RASTER resolution
#keep boundary settings
g.region nsres=$NSRES ewres=$EWRES -ap > /dev/null

#prepare raster MASK
v.to.rast in=$VECTOR out=${VECTOR}_${TMPNAME} use=cat > /dev/null 2> /dev/null
if [ $? -ne 0 ] ; then
 echo "An error occurred."
 exit 1
fi

CATSLIST="`r.cats ${VECTOR}_${TMPNAME} fs=';' 2> /dev/null | cut -d';' -f1 | tr '\n' ' '`"
echo "List of categories found: $CATSLIST"

#check if DBF driver used, in this case cut to 10 chars col names:
DBFDRIVER=0
v.db.connect -g $VECTOR | cut -d' ' -f5 | grep -i dbf > /dev/null
if [ $? -eq 0 ] ; then
  DBFDRIVER=1
else
  # in case a table is missing, we'll trap a crash later...
  DBFDRIVER=0
fi

for i in n min max range mean stddev variance cf_var sum ; do
  #check if column already present
  if [ $DBFDRIVER -eq 1 ] ; then
     CURRCOLUMN="`echo ${COLPREFIX}_${i} | cut -b1-10`"
  else
     CURRCOLUMN="${COLPREFIX}_${i}"
  fi
  v.info -c $VECTOR 2> /dev/null | sed 's+^+|+g' |sed 's+$+|+g' | grep "|$CURRCOLUMN|" > /dev/null
  if [ $? -eq 0 ] ; then
    echo "$column $CURRCOLUMN already present, updating statistic values in table"
    if [ $GIS_FLAG_c -ne 1 ] ; then
       echo "ERROR: Cannot continue (or use -c flag)."
       exit 1
    fi
  else
    v.db.addcol map=$VECTOR columns="$CURRCOLUMN double"
    if [ $? -eq 0 ] ; then
      echo "ERROR: Cannot continue."
      exit 1
    fi
  fi
done

#loop over cats and calculate statistics:
NUMBER=`echo $CATSLIST | tr ' ' '\n' | wc -l | awk '{print $1}'`
CURRNUM=1
for i in $CATSLIST ; do
 echo "Processing category $i ($CURRNUM/$NUMBER)"
 g.remove MASK > /dev/null 2> /dev/null
 r.mapcalc "MASK=if(${VECTOR}_${TMPNAME} == $i, 1, null())" 2> /dev/null
 #n, min, max, range, mean, stddev, variance, coeff_var, sum
 n=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f1`
 min=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f2`
 max=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f3`
 range=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f4`
 mean=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f5`
 stddev=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f6`
 variance=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f7`
 cf_var=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f8`
 sum=`r.univar -g $RASTER | cut -d'=' -f2 | tr '\n' ' ' | cut -d' ' -f9`

 if [ $DBFDRIVER -eq 1 ] ; then
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_n| cut -b1-10`"        value=$n        where="cat=$i"
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_min| cut -b1-10`"      value=$min      where="cat=$i"
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_max| cut -b1-10`"      value=$max      where="cat=$i"
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_range| cut -b1-10`"    value=$range    where="cat=$i"
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_mean| cut -b1-10`"     value=$mean     where="cat=$i"
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_stddev| cut -b1-10`"   value=$stddev   where="cat=$i"
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_variance| cut -b1-10`" value=$variance where="cat=$i"
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_cf_var| cut -b1-10`"   value=$cf_var   where="cat=$i"
  v.db.update map=$VECTOR col="`echo ${COLPREFIX}_sum| cut -b1-10`"      value=$sum      where="cat=$i"
 else
  v.db.update map=$VECTOR col=${COLPREFIX}_n         value=$n         where="cat=$i"
  v.db.update map=$VECTOR col=${COLPREFIX}_min       value=$min       where="cat=$i"
  v.db.update map=$VECTOR col=${COLPREFIX}_max       value=$max       where="cat=$i"
  v.db.update map=$VECTOR col=${COLPREFIX}_range     value=$range     where="cat=$i"
  v.db.update map=$VECTOR col=${COLPREFIX}_mean      value=$mean      where="cat=$i"
  v.db.update map=$VECTOR col=${COLPREFIX}_stddev    value=$stddev    where="cat=$i"
  v.db.update map=$VECTOR col=${COLPREFIX}_variance  value=$variance  where="cat=$i"
  v.db.update map=$VECTOR col=${COLPREFIX}_cf_var    value=$cf_var    where="cat=$i"
  v.db.update map=$VECTOR col=${COLPREFIX}_sum       value=$sum       where="cat=$i"
 fi

 CURRNUM=`expr $CURRNUM + 1`
done

g.remove MASK > /dev/null 2> /dev/null

echo "Done. Statistics calculated from raster map <$RASTER> and uploaded to attribute table of vector map <$VECTOR>."

cleanup
