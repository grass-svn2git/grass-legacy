#!/bin/sh

############################################################################
#
# MODULE:	v.rast.stats
# AUTHOR(S):	Markus Neteler
# PURPOSE:	Calculates univariate statistics from a GRASS raster map
#		only for areas covered by vector objects on a per-category base
# COPYRIGHT:	(C) 2005 by the GRASS Development Team
#
#		This program is free software under the GNU General Public
#		License (>=v2). Read the file COPYING that comes with GRASS
#		for details.
#
# TODO: do we need layer= management?
#############################################################################

#%Module
#%  description: Calculates univariate statistics from a GRASS raster map based on vector polygons and uploads statistics to new attribute columns.
#%  keywords: vector, raster, statistics
#%End
#%flag
#%  key: c
#%  description: Continue if upload column(s) already exist
#%END
#%flag
#%  key: e
#%  description: Calculate extended statistics
#%END
#%option
#% key: vector
#% type: string
#% key_desc: name
#% gisprompt: old,vector,vector
#% description: Name of vector polygon map
#% required : yes
#%End
#%option
#% key: layer
#% type: integer
#% description: Layer to which the table to be changed is connected
#% answer: 1
#% required : no
#%end
#%option
#% key: raster
#% type: string
#% key_desc: name
#% gisprompt: old,cell,raster
#% description: Name of raster map to calculate statistics from
#% required : yes
#%END
#%option
#% key: colprefix
#% type: string
#% description: Column prefix for new attribute columns
#% required : yes
#%end
#%option
#% key: percentile
#% type: integer
#% description: Percentile to calculate (requires extended statistics flag)
#% options: 0-100
#% answer: 90
#% required : no
#%end

if  [ -z "$GISBASE" ] ; then
    echo "You must be in GRASS GIS to run this program." >&2
    exit 1
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
    exec g.parser "$0" "$@"
fi

PROG=`basename $0`

#### check if we have awk
if [ ! -x "`which awk`" ] ; then
    g.message "awk required, please install awk or gawk first" 
    exit 1
fi

# setting environment, so that awk works properly in all languages
unset LC_ALL
LC_NUMERIC=C
export LC_NUMERIC

#### setup temporary file
TEMPFILE="`g.tempfile pid=$$`"
if [ $? -ne 0 ] || [ -z "$TEMPFILE" ] ; then
    g.message -e "Unable to create temporary files" 
    exit 1
fi
SQLTMP="$TEMPFILE.sql"
# we need a random name
TMPNAME=`basename "$TEMPFILE"`

cleanup()
{
   #restore settings:
   g.region region="$TMPNAME"
   g.remove region="$TMPNAME" --quiet
   g.remove rast="${VECTOR}_${TMPNAME}" --quiet
   g.remove MASK --quiet 2>/dev/null
   if [ $MASKFOUND -eq 1 ] ; then
      g.message "Restoring previous MASK..."
      g.rename "${TMPNAME}_origmask",MASK --quiet
   fi
   rm -f "$TEMPFILE" "$TMPNAME" "$TEMPFILE.cats" "$SQLTMP"
}

# what to do in case of user break:
exitprocedure()
{
   g.message -e 'User break!'
   cleanup
   exit 1
}
# shell check for user break (signal list: trap -l)
trap "exitprocedure" 2 3 15


RASTER="$GIS_OPT_RASTER"
COLPREFIX="$GIS_OPT_COLPREFIX"

### setup enviro vars ###
eval `g.gisenv`
: ${GISBASE?} ${GISDBASE?} ${LOCATION_NAME?} ${MAPSET?}

# does map exist in CURRENT mapset?
eval `g.findfile element=vector file="$GIS_OPT_VECTOR" mapset="$MAPSET"`
VECT_MAPSET=`echo "$GIS_OPT_VECTOR" | grep '@' | cut -f2 -d'@'`
if [ -z "$VECT_MAPSET" ] ; then
   VECT_MAPSET="$MAPSET"
fi
if [ ! "$file" ] || [ "$VECT_MAPSET" != "$MAPSET" ] ; then
   g.message -e "Vector map <$GIS_OPT_VECTOR> not found in current mapset"
   exit 1
else
   VECTOR=`echo "$GIS_OPT_VECTOR" | cut -f1 -d'@'`
fi

#check the input raster map
eval `g.findfile element=cell file="$RASTER"`
if [ ! "$file" ] ; then
   g.message -e "Raster map <$RASTER> not found"
   exit 1
fi

#check presence of raster MASK, put it aside
MASKFOUND=0
eval `g.findfile element=cell file=MASK`
if [ "$file" ] ; then
   g.message "Raster MASK found, temporarily disabled"
   g.rename MASK,"${TMPNAME}_origmask" --quiet
   MASKFOUND=1
fi

#get RASTER resolution of map which we want to query:
#fetch separated to permit for non-square cells (latlong etc)
NSRES=`r.info -s "$RASTER" | grep nsres | cut -d'=' -f2`
if [ $? -ne 0 ] ; then
   g.message -e "An error occurred reading the input raster map resolution."
   cleanup
   exit 1
fi
EWRES=`r.info -s "$RASTER" | grep ewres | cut -d'=' -f2`

#save current settings:
g.region save="$TMPNAME" --quiet

#Temporarily setting raster resolution to $RASTER resolution
#keep boundary settings
g.region nsres=$NSRES ewres=$EWRES -a

#prepare raster MASK
v.to.rast in="$VECTOR" out="${VECTOR}_${TMPNAME}" use=cat --quiet
if [ $? -ne 0 ] ; then
   g.message -e "An error occurred while converting vector to raster"
   cleanup
   exit 1
fi


#dump cats to file to avoid "too many argument" problem:
r.category "${VECTOR}_${TMPNAME}" fs=';' --quiet | cut -d';' -f1 > "$TEMPFILE.cats"
#echo "List of categories found: $CATSLIST"
NUMBER=`cat "$TEMPFILE.cats" | wc -l | awk '{print $1}'`
if [ $NUMBER -lt 1 ] ; then
   g.message -e "No categories found in raster map"
   cleanup
   exit 1
fi


#check if DBF driver used, in this case cut to 10 chars col names:
DBFDRIVER=0
v.db.connect -g "$VECTOR" fs=";" | grep -w "^$GIS_OPT_LAYER" | \
   cut -d';' -f5 | grep -i dbf --quiet
if [ $? -eq 0 ] ; then
   DBFDRIVER=1
else
   # in case a table is missing, we'll trap a crash later...
   DBFDRIVER=0
fi
# we need this for non-DBF driver:
DB_SQLDRIVER=`v.db.connect -g "$VECTOR" fs=";" | cut -d';' -f5`
DB_DATABASE="`v.db.connect -g "$VECTOR" fs=";" | cut -d';' -f4`"

#Find out which table is linked to the vector map on the given layer
TABLE=`v.db.connect map="$VECTOR" -g fs=";" | grep -w "^$GIS_OPT_LAYER" | awk -F ";" '{print $2}'`
if [ -z "$TABLE" ] ; then
   g.message -e 'There is no table connected to this map! Run v.db.connect or v.db.addtable first.'
   exit 1
fi


BASECOLS="n min max range mean stddev variance cf_var sum"

# do extended stats?
if [ $GIS_FLAG_E -eq 1 ] ; then
   # namespace is limited in DBF but the % value is important
   if [ $DBFDRIVER -eq 1 ] ; then
      PERCCOL="per$GIS_OPT_PERCENTILE"
   else
      PERCCOL="percentile_$GIS_OPT_PERCENTILE"
   fi
   EXTRACOLS="first_quartile median third_quartile $PERCCOL"
else
   EXTRACOLS=""
fi


unset ADDCOLS
for i in $BASECOLS $EXTRACOLS ; do
  #check if column already present
  if [ $DBFDRIVER -eq 1 ] ; then
     CURRCOLUMN="`echo "${COLPREFIX}_${i}" | cut -b1-10`"
  else
     CURRCOLUMN="${COLPREFIX}_${i}"
  fi
  v.info -c $VECTOR --quiet | sed 's+^+|+g' | sed 's+$+|+g' | \
    grep "|$CURRCOLUMN|" --quiet
  if [ $? -eq 0 ] ; then
    if [ $GIS_FLAG_C -ne 1 ] ; then
       g.message -e "Cannot create column <$CURRCOLUMN> (already present). \
         Use -c flag to update values in this column."
       cleanup
       exit 1
    fi
  else
    if [ -n "$ADDCOLS" ] ; then
       ADDCOLS="$ADDCOLS,"
    fi
    if [ "$i" = "n" ] ; then
       COLTYPE="INTEGER"
    else
       COLTYPE="DOUBLE PRECISION"
    fi
    ADDCOLS="$ADDCOLS $CURRCOLUMN $COLTYPE"
  fi
done

g.message -v "Adding columns <$ADDCOLS>"
v.db.addcol map="$VECTOR" columns="$ADDCOLS"
if [ $? -ne 0 ] ; then
   g.message -e "Cannot continue (problem adding columns)."
   cleanup
   exit 1
fi


#loop over cats and calculate statistics:
g.message -v "Processing data ..."
CURRNUM=1
# get rid of any earlier attempts
rm -f "$SQLTMP"

# do extended stats?
if [ $GIS_FLAG_E -eq 1 ] ; then
   EXTSTAT="-e"
else
   EXTSTAT=""
fi

for i in `cat "$TEMPFILE.cats"` ; do
   g.message -v message="Processing category $i ($CURRNUM/$NUMBER)"
   g.remove MASK --quiet 2>/dev/null
   # r.mapcalc doesn't use the parser, so we set the env var version instead
   GRASS_VERBOSE=0 \
     r.mapcalc "MASK=if(${VECTOR}_${TMPNAME} == $i, 1, null())"

   #n, min, max, range, mean, stddev, variance, coeff_var, sum
   unset $BASECOLS $EXTRACOLS
   eval `r.univar -g $EXTSTAT map="$RASTER" percentile="$GIS_OPT_PERCENTILE" | sed 's+nan+NULL+g'`
   # How to test r.univar $? exit status? using -e creates the real possibility of out-of-memory errors

   cf_var="$coeff_var"
   if [ $GIS_FLAG_E -eq 1 ] && [ $DBFDRIVER -eq 1 ] ; then
      eval "$PERCCOL=\$percentile_$GIS_OPT_PERCENTILE"
   fi

   for var in $BASECOLS $EXTRACOLS ; do
      eval value=\${$var}

      if [ $DBFDRIVER -eq 1 ] ; then
	colname="`echo "${COLPREFIX}_${var}" | cut -b1-10`"
      else
	colname="${COLPREFIX}_${var}"
      fi

      echo "UPDATE $TABLE SET ${colname}=${value} WHERE cat=$i;" >> "$SQLTMP"
   done

   CURRNUM=`expr $CURRNUM + 1`
done


g.message -v "Updating the database ..."
db.execute input="$SQLTMP" database="${DB_DATABASE}" driver="$DB_SQLDRIVER"
EXITCODE=$?


g.remove MASK --quiet 2>/dev/null

cleanup

if [ "$EXITCODE" -eq 0 ] ; then
  g.message "Statistics calculated from raster map <$RASTER> and uploaded to \
    attribute table of vector map <$VECTOR>."
  g.message "Done."
fi

exit $EXITCODE
