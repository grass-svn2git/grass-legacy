/*! \mainpage Vector_Library GRASS 6 Vector Architecture

by GRASS Development Team

http://grass.itc.it

\section intro Introduction

This description covers the new GRASS 6 vector library
architecture.  This new architecture overcomes the vector limitations
of GRASS 4.x-5.4.x by extending the vector support with attributes
stored in external relational databases and by new 3D
capabilities. Besides internal file based storage the geometry may
alternatively be stored in PostGIS database. This enables users to
maintain large data sets with simultaneous write access. External GIS
formats such as SHAPE-files may be used directly without necessity of
format conversion.

\section background Background

generally, the vector data model is used to describe geographic
phenomena which may be represented by geometric entities (primitives)
like points, lines, and areas. The GRASS vector data model includes
the description of topology, where besides the coordinates -
describing the location of the points, lines, boundaries and centroids
- also their spatial relations are stored. In general, topological GIS
require a data structure where common boundary between two adjacent
areas is stored as a single line, simplifying the map maintenance.

\section libraries Libraries

Besides internal library functions there are two main libraries:


\subsection vlib Vlib (Vector library)

For details please read Blazek et al. 2002 (see below) as well as the
references in this document.

\subsubsection vlibspidx Vector library categories and layers

<P>
<i>Note: "layer" was called "field" in earlier version.</i>
<P>

In GRASS a "category" is a feature ID used to link geometry
with attributes stored in one or many (external) database table(s).
Each vector feature inside a vector map has zero, one or more
&lt;layer,category&gt; tuple(s). A user can (but not must) create attribute
tables which are referenced by the layer, and rows which are essentially
referenced by the &lt;layer,category&gt; pair.

\subsubsection vlibspidx Vector library spatial index management

Spatial index (based on R-tree) is calculated on the fly.

Spatial index occupies a lot of memory but it is necessary for 
topology building. Also, it takes long time to release the memory
occupied by spatial index (dig_spidx_free()). 

The function building topology (Vect_build()) is usually called 
at the end of module (before Vect_close()) so it is faster to call
exit() and operating system releases all the memory much faster.
By default the memory is not released.

It is possible to call Vect_set_release_support() before Vect_close()
to enforce memory release, but it takes long time on large files.

Currently most of the modules do not release the memory occupied for
spatial index and work like this (pseudocode):

\verbatim
int 
main
{
     Vect_open_new()
     //writing new vector

     Vect_build()
     Vect_close()  // memory is not released
}
\endverbatim

In general it is possible to free the memory with Vect_set_release_support()
such as:

\verbatim
int 
main
{
     Vect_open_new()
     // writing new vector

     Vect_build()
     Vect_set_release_support()
     Vect_close()  // memory is released
}
\endverbatim

but it only takes longer time. 
<P>
It make sense to release spatial index if it is used only at the beginning
of a module or in permanently running programs like QGIS.
For example:

\verbatim
int 
main
{
     Vect_open_old()
     // select features using spatial index, e.g.  Vect_select_lines_by_box()
     Vect_set_release_support()
     Vect_close()  // memory is released

     // do some processing which needs memory
}
\endverbatim


\subsubsection vlibtopo Vector library topology management

Topology is generated for all kinds of vector types.  Memory is not
released by default. The programmer can force the library to release
the memory by using Vect_set_release_support(). But: The programmer
cannot run Vect_set_release_support() in mid process because all
vectors are needed in the spatial index is needed to build topology.

Topology is also necessary for points in case of vector network
because the graph is built using topology informations about lines
and points.

The topology structure does not only store the topology but also
'line' bounding box and line offset in coor file (index).
The existing spatial index is using line ID in 'topology' structure
to identify lines in 'coor' file. Currently it is not possile to build
spatial index without topology.

\subsubsection vlibtopo_coor coor file

<ol>
<li> In the coor file the following is stored: 'line' (element) type,
    number of attributes and layer number for each category.
<li> Coordinates in binary file are stored as double (8 bytes).
</ol>

\subsubsection vlibtin Vector TINs

TINs are created as 2D/3D vector polygons consisting of 3 vertices.

\subsection dglib DGLib (Directed Graph Library)

The Directed Graph Library or DGLib (Micarelli 2002,
http://grass.itc.it/dglib/) provides functionality for vector network
analysis. This library released under GPL is hosted by the GRASS project (in
the CVS server within the GRASS source code). As stand-alone library it
may also be used by other software project.

The Directed Graph Library library provides functionality to assign costs to
lines and/or nodes. That means that costs can be accumulated while traveling
along polylines. The user can assign individual costs to all lines and/or
nodes of a vector map and later calculate shortest path connections based on
the accumulated costs. Applications are transport analysis, connectivity and
more. 

For details please read Blazek et al. 2002 (see below).


\section vlibfunc List of vector library functions

The Vect_*() functions are the programmer's API for GRASS vector
programming.


\section area area

Vect_get_area_area();

Vect_get_area_boundaries();

Vect_get_area_centroid();

Vect_get_area_isle();

Vect_get_area_num_isles();

Vect_get_area_points();

Vect_get_isle_area();

Vect_get_isle_boundaries();

Vect_get_isle_points();

Vect_point_in_area();


\section array array

Vect_new_varray();

Vect_set_varray_from_cat_list();

Vect_set_varray_from_cat_string();

Vect_set_varray_from_db();


\section box box

Vect_box_copy();

Vect_box_extend();

Vect_box_overlap();

Vect_get_area_box();

Vect_get_isle_box();

Vect_get_line_box();

Vect_get_map_box();

Vect_point_in_box();

Vect_region_box();


\section break_lines break_lines

Vect_break_lines();


\section break_polygons break_polygons

Vect_break_polygons();


\section bridges bridges

Vect_remove_bridges();


\section buffer buffer

Vect_line_buffer();

Vect_line_parallel();


\section build build

Vect_build();

Vect_build_partial();

Vect_get_built();

Vect_save_spatial_index();

Vect_save_topo();

Vect_spatial_index_dump();

Vect_topo_dump();


\section build_nat build_nat

Vect_attach_centroids();

Vect_attach_isle();

Vect_attach_isles();

Vect_build_line_area();

Vect_build_nat();

Vect_isle_find_area();


\section build_ogr build_ogr

Vect_build_ogr();


\section cats cats

Vect_array_to_cat_list();

Vect_cat_del();

Vect_cat_get();

Vect_cat_in_array();

Vect_cat_in_cat_list();

Vect_cat_set();

Vect_destroy_cat_list();

Vect_destroy_cats_struct();

Vect_field_cat_del();

Vect_new_cat_list();

Vect_new_cats_struct();

Vect_reset_cats();

Vect_str_to_cat_list();


\section cindex cindex

Vect_cidx_dump();

Vect_cidx_find_next();

Vect_cidx_get_cat_by_index();

Vect_cidx_get_field_index();

Vect_cidx_get_field_number();

Vect_cidx_get_num_cats_by_index();

Vect_cidx_get_num_fields();

Vect_cidx_get_num_types_by_index();

Vect_cidx_get_num_unique_cats_by_index();

Vect_cidx_get_type_count();

Vect_cidx_get_type_count_by_index();

Vect_cidx_open();

Vect_cidx_save();


\section clean_nodes clean_nodes

Vect_clean_small_angles_at_nodes();


\section close close

Vect_close();


\section constraint constraint

Vect_get_constraint_box();

Vect_remove_constraints();

Vect_set_constraint_region();

Vect_set_constraint_type();


\section dangles dangles

Vect_chtype_dangles();

Vect_remove_dangles();


\section dbcolumns dbcolumns

Vect_get_column_names();

Vect_get_column_names_types();

Vect_get_column_types();


\section error error

Vect_get_fatal_error();

Vect_set_fatal_error();


\section field field

Vect_add_dblink();

Vect_check_dblink();

Vect_default_field_info();

Vect_get_dblink();

Vect_get_field();

Vect_map_add_dblink();

Vect_map_check_dblink();

Vect_map_del_dblink();

Vect_new_dblinks_struct();

Vect_read_dblinks();

Vect_reset_dblinks();

Vect_subst_var();

Vect_write_dblinks();


\section find find

Vect_find_area();

Vect_find_island();

Vect_find_line();

Vect_find_node();


\section graph graph

Vect_graph_add_edge();

Vect_graph_init();

Vect_graph_set_node_costs();

Vect_graph_shortest_path();


\section header header

Vect_get_comment();

Vect_get_date();

Vect_get_full_name();

Vect_get_map_date();

Vect_get_map_name();

Vect_get_mapset();

Vect_get_name();

Vect_get_organization();

Vect_get_person();

Vect_get_proj();

Vect_get_proj_name();

Vect_get_scale();

Vect_get_zone();

Vect_is_3d();

Vect_print_header();

Vect_set_comment();

Vect_set_date();

Vect_set_map_date();

Vect_set_map_name();

Vect_set_organization();

Vect_set_person();

Vect_set_scale();

Vect_set_thresh();

Vect_set_zone();


\section hist hist

Vect_hist_command();

Vect_hist_copy();

Vect_hist_read();

Vect_hist_rewind();

Vect_hist_write();


\section init_head init_head

Vect_copy_head_data();


\section intersect intersect

Vect_line_check_intersection();

Vect_segment_intersection();


\section legal_vname legal_vname

Vect_check_input_output_name();


\section level level

Vect_level();


\section level_two level_two

Vect_get_centroid_area();

Vect_get_line_areas();

Vect_get_line_nodes();

Vect_get_node_coor();

Vect_get_node_line();

Vect_get_node_line_angle();

Vect_get_node_n_lines();

Vect_get_num_areas();

Vect_get_num_dblinks();

Vect_get_num_islands();

Vect_get_num_lines();

Vect_get_num_nodes();

Vect_get_num_primitives();

Vect_get_num_updated_lines();

Vect_get_num_updated_nodes();

Vect_get_updated_line();

Vect_get_updated_node();


\section line line

Vect_append_point();

Vect_append_points();

Vect_copy_pnts_to_xyz();

Vect_copy_xyz_to_pnts();

Vect_destroy_line_struct();

Vect_line_box();

Vect_line_delete_point();

Vect_line_distance();

Vect_line_geodesic_length();

Vect_line_insert_point();

Vect_line_length();

Vect_line_prune();

Vect_line_prune_thresh();

Vect_line_reverse();

Vect_line_segment();

Vect_new_line_struct();

Vect_point_on_line();

Vect_points_distance();

Vect_reset_line();


\section list list

Vect_destroy_list();

Vect_list_append();

Vect_list_append_list();

Vect_list_delete();

Vect_list_delete_list();

Vect_reset_list();

Vect_val_in_list();


\section map map

Vect_copy();

Vect_copy_map_lines();

Vect_copy_table();

Vect_copy_table_by_cats();

Vect_copy_tables();

Vect_delete();

Vect_rename();


\section net net

Vect_net_build_graph();

Vect_net_nearest_nodes();

Vect_net_shortest_path();

Vect_net_shortest_path_coor();


\section open open

Vect_coor_info();

Vect_maptype_info();

Vect_open_new();

Vect__open_old();

Vect_open_old();

Vect_open_old_head();

Vect_open_spatial_index();

Vect_open_topo();

Vect_open_update();

Vect_open_update_head();

Vect_set_open_level();



\section overlay overlay

Vect_overlay();

Vect_overlay_and();

Vect_overlay_str_to_operator();


\section poly poly

Vect_find_poly_centroid();

Vect_get_point_in_area();

Vect_get_point_in_poly();

Vect_get_point_in_poly_isl();


\section read read

Vect_area_alive();

Vect_isle_alive();

Vect_line_alive();

Vect_node_alive();

Vect_read_line();

Vect_read_next_line();


\section remove_areas remove_areas

Vect_remove_small_areas();


\section remove_duplicates remove_duplicates

Vect_remove_duplicates();


\section rewind rewind

Vect_rewind();


\section rewind_nat rewind_nat


\section rewind_ogr rewind_ogr


\section select select

Vect_select_areas_by_box();

Vect_select_areas_by_polygon();

Vect_select_isles_by_box();

Vect_select_lines_by_box();

Vect_select_lines_by_polygon();

Vect_select_nodes_by_box();


\section sindex sindex

Vect_spatial_index_add_item();

Vect_spatial_index_del_item();

Vect_spatial_index_destroy();

Vect_spatial_index_init();

Vect_spatial_index_select();


\section snap snap

Vect_snap_lines();


\section tin tin

Vect_tin_get_z();


\section type type

Vect_option_to_types();


\section write write

Vect_rewrite_line();

Vect_write_line();

\section contacts Contacts

 Radim Blazek (vector architecture) <blazek@itc.it>

 Roberto Micarelli (DGLib) <mi.ro@iol.it>

\section references References

Text based on: R. Blazek, M. Neteler, and R. Micarelli. The new GRASS 5.1
 vector architecture. In Open source GIS - GRASS users conference 2002,
 Trento, Italy, 11-13 September 2002. University of Trento, Italy, 2002.
 <a href="http://www.ing.unitn.it/~grass/conferences/GRASS2002/proceedings/proceedings/pdfs/Blazek_Radim.pdf">http://www.ing.unitn.it/~grass/conferences/GRASS2002/proceedings/proceedings/pdfs/Blazek_Radim.pdf</a>
 

\section seealso See Also

DBMI - Database Management Interface: \ref DataBase_Management_Interface

Last change: $Date$
*/
