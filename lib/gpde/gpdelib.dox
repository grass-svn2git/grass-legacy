/*! \page gpdelib GRASS partial differential equations Library 

<h2>GRASS partial differential equations Library</h2>

<P>
Author: Soeren Gebbert

<b>Overview</b>

The GRASS partial differential equation library is designed to support the
solution of PDE's within GRASS.
Therefore it provides functions to create and solve linear equation systems.
The library design is thread safe and supports threaded parallelism with OpenMP. All available solvers 
and the assembling of the linear equation systems are parallelized with OpenMP. 
The creation of a linear equation system can be done by using quadratic or sparse matrices.
Sparse and quadratic matrices are supported by the iterative equation solvers, the direct equation solvers only support 
regular quadratic matrices.
<p>
To enable parallel computing, you will need a compiler with OpenMP capabilities.
Most proprietary compilers support OpenMP. The free gnu-C compiler supports OpenMP since version 4.2.
More informations about OpenMP are available at http://www.openmp.org .
<br>
<br>
Based on the finite volume discretization for structured grids, 
groundwater flow in 2d and 3d are implemented. 
It is IMHO easy to add any partial differential equation which can be 
solved with the finite volume or the finite differences method based on structured grids.
The basis for the discretisation is the geometrical structure of raster and volume maps.
<br>
<br>
There are plans to implement heat flow in two and three dimensions, as well as 
solute transport in groundwater in two and three dimensions.

\section PDE The Creation of a lineare equation systems

The principle to create and solve a linear equation system with this library:
\verbatim
1.) Read all needed raster/volume data into the memory
    - use the the two and three dimensional data arrays N_array_2d and N_array_3d
      to manage the data
2.) Assemble the linear equation system
    - use the sparse matrix structure to save lots of memory and cpu time
3.) Solve the linear equation system with the gauss, cg or bicgstab method
    - always prefer the iterative krylov-space methods for solving
    - the available direct solvers dont support sparse matrices
4.) Write the result back as raster/volume map
\endverbatim

The following code shows how to implement this principle with the GRASS PDE lib:

\verbatim
/* *************************************************************** */
/* ****** calculate the 2d dimensional groundwater flow ********** */
/* *************************************************************** */
int main()
{
    int i, j;
    N_gwflow_data2d *data; 	/* data structure with the groundwater data		*/
    N_geom_data *geom; 		/* geometry of the calculation area (region)		*/
    N_les *les; 		/* the linear equation system structure			*/
    N_les_callback_2d *call;	/* the callback for the groundwater flow calulation	*/

    /*allocate the callback structure*/
    call = N_alloc_les_callback_2d();

    /*set the callback to groundwater flow calculation*/
    N_set_les_callback_2d_func(call, (*N_callback_gwflow_2d));

   /*allocate the groundwater data structure with one million cells*/
    data = N_alloc_gwflow_data2d(1000, 1000);

    /*set the time stept*/
    data->dt = 8640000;

    /*set the geometric data (should be read from a region)*/
    geom = N_alloc_geom_data();

    geom->dx = 10; /*distance between two cells in x direction*/
    geom->dy = 15; /*distance between two cells in y direction*/

    geom->Az = 150; /*area of on pixel*/

    /*the geometry of a square area with one million cells*/
    geom->rows = 1000;
    geom->cols = 1000;

    /*fill the data arrays with valid data in parallel*/
    /*normaly the data should be read from some raster maps*/

    #pragma omp parallel for private (k, i, j) shared (data)
    for (i = 0; i < geom->rows; i++) {
        for (j = 0; j < geom->cols; j++) {
            if (i == 0) {
                N_put_array_2d_value_dcell(data->phead, i, j, 50);
                N_put_array_2d_value_dcell(data->phead_start, i, j, 50);
                N_put_array_2d_value_dcell(data->status, i, j, N_CELL_DIRICHLET);
            }
            else {

                N_put_array_2d_value_dcell(data->phead, i, j, 40);
                N_put_array_2d_value_dcell(data->phead_start, i, j, 40);
                N_put_array_2d_value_dcell(data->status, i, j, N_CELL_ACTIVE);
            }
            N_put_array_2d_value_dcell(data->T_x, i, j, 30.0001);
            N_put_array_2d_value_dcell(data->T_y, i, j, 30.0001);
            N_put_array_2d_value_dcell(data->q, i, j, 0.0);
            N_put_array_2d_value_dcell(data->s, i, j, 0.001);
            N_put_array_2d_value_dcell(data->r, i, j, 0.0);
            N_put_array_2d_value_dcell(data->nf, i, j, 0.1);
        }
    }

    /*Assemble the sparse matrix */
    les = N_assemble_les_2d(N_SPARSE_LES, geom, data->status, data->phead_start, (void *)data, call);

    /*Solve the linear equation system with the cg method*/
    N_solver_cg(les, 100000, 0.1e-8);

    /*write the x vector of the les back into a raster map -- this is skipped here*/

    /*free the memory*/
    N_free_les(les);
    N_free_gwflow_data2d(data);
    G_free(geom);
    G_free(call);

    return 0;
}

\endverbatim

The assembling of the lineare equation system is based on a 5 point star for raster maps and a
7 point star for volume maps, implemented as finite volume/differences discretization. 

<p>
All data maps which are used to create a linear equation system must loaded completely into the memory.
Therefore 2d and 3d data structures are implemented to support this principle:

\subsection rastermaps Raster maps

\verbatim
typedef struct
{
    int type;                   /* which raster type CELL_TYPE, FCELL_TYPE, DCELL_TYPE */
    int rows, cols;
    int rows_intern, cols_intern;
    int offset;                 /*number of cols/rows offset at each boundary */
    CELL *cell_array;
    FCELL *fcell_array;
    DCELL *dcell_array;
} N_array_2d;
\endverbatim

For performance reasons the data arrays are stored as a one dimensional array internally.

<br><br>
Use the following functions for memory allocation and value handling:
<p>
Memory allocation<br>
N_array_2d *#N_alloc_array_2d(int rows, int cols, int offset, int type);
<p>
void #N_free_array_2d(N_array_2d * data_array);
<p>
Get the type of the array<br>
int #N_get_array_2d_type(N_array_2d * array2d);
<p>
void #N_get_array_2d_value(N_array_2d * array2d, int row, int col, void *value);
<p>
CELL #N_get_array_2d_value_cell(N_array_2d * array2d, int row, int col);
<p>
FCELL #N_get_array_2d_value_fcell(N_array_2d * array2d, int row, int col);
<p>
DCELL #N_get_array_2d_value_dcell(N_array_2d * array2d, int row, int col);
<p>
void #N_put_array_2d_value(N_array_2d * array2d, int row, int col, char *value);
<p>
void #N_put_array_2d_value_cell(N_array_2d * array2d, int row, int col, CELL value);
<p>
void #N_put_array_2d_value_fcell(N_array_2d * array2d, int row, int col, FCELL value);
<p>
void #N_put_array_2d_value_dcell(N_array_2d * array2d, int row, int col, DCELL value);
<p>
void #N_array_2d_copy(N_array_2d * source, N_array_2d * target);
<p>

\subsection g3dmaps Volume maps
\verbatim
typedef struct
{
    int type;                   /* which raster type G3D_FLOAT, G3D_DOUBLE */
    int rows, cols, depths;
    int rows_intern, cols_intern, depths_intern;
    int offset;                 /*number of cols/rows/depths offset at each boundary */
    float *float_array;
    double *double_array;
} N_array_3d;
\endverbatim
For performance reasons the data arrays are stored as a one dimensional array internally.

<br><br>
The following functions should be used for memory allocation and value handling:
<p>
N_array_3d *#N_alloc_array_3d(int depths, int rows, int cols, int offset, int type);
<p>
void #N_free_array_3d(N_array_3d * data_array);
<p>
int #N_get_array_3d_type(N_array_2d * array2d);
<p>
void #N_get_array_3d_value(N_array_3d * array3d, int depth, int row, int col, void *value);
<p>
float #N_get_array_3d_value_float(N_array_3d * array3d, int depth, int row, int col);
<p>
double #N_get_array_3d_value_double(N_array_3d * array3d, int depth, int row, int col);
<p>
void #N_put_array_3d_value(N_array_3d * array3d, int depth, int row, int col, char *value);
<p>
void #N_put_array_3d_value_float(N_array_3d * array3d, int depth, int row, int col, float value);
<p>
void #N_put_array_3d_value_double(N_array_3d * array3d, int depth, int row, int col, double value);
<p>
void #N_array_3d_copy(N_array_3d * source, N_array_3d * target);
<p>

\subsection les Entries in the linear equation system

To make entries in the linear equation system, a special structure must be provided.
Currently implemented structures includes the 5 point and 7 point star scheme:

\verbatim
Matrix entries for the mass balance of a 5 star system

The entries are center, east, west, north, south and the
right side vector b of Ax = b. This system is typical used in 2d.

     N
     |
 W-- C --E
     |
     S

Matrix entries for the mass balance of a 7 star system

The entries are center, east, west, north, south, top, bottom and the
right side vector b of Ax = b. This system is typical used in 3d.

     T N
     |/
 W-- C --E
    /|
   S B

Matrix entries for the mass balance of a 9 star system

The entries are center, east, west, north, south, north-east, south-east,
north-wast, south-west and the
right side vector b of Ax = b. This system is typical used in 2d.

 NW  N  NE
   \ | /
 W-- C --E
   / | \
 SW  S  SE


typedef struct
{
    int type;
    int count;
    double W, E, N, S, C, T, B, NE, NW, SE, SW, V;
} N_les_row_entries;
\endverbatim

The following functions should be used to create and handle the #N_les_row_entries structure:

<p>
Memory allocation<br>
N_les_row_entries *#N_alloc_5star();
<p>
N_les_row_entries *#N_alloc_7star();
<p>
N_les_row_entries *#N_alloc_9star();
<p>
Memory allocation with initialisation<br>
N_les_row_entries *#N_create_5star(double C, double W, double E, double N, double S, double V);
<p>
N_les_row_entries *#N_create_7star(double C, double W, double E, double N, double S, double T, double B, double V);
<p>
N_les_row_entries *#N_create_9star(double C, double W, double E, double N, double S, double NW, double SW, double NE, double SE, double V);
<p>

<p>
\subsection les functions to assemble the lineare equation system

<p>
Setting the callback function which fills the 5 or 7 point structure for every row of the linear equation system (eg: for each cell of the raster or volume map)
<p>
void #N_set_les_callback_3d_func(N_les_callback_3d * data, N_les_row_entries * (*callback_func_3d) ());
<p>
void #N_set_les_callback_2d_func(N_les_callback_2d * data, N_les_row_entries * (*callback_func_2d) ());
<p>
Allocation the callback structure for 2d and 3d
<p>
N_les_callback_3d *#N_alloc_les_callback_3d();
<p>
N_les_callback_2d *#N_alloc_les_callback_2d();

<p>
Assemble the linear equation system in 2d or 3d

<p>
N_les *#N_assemble_les_3d(int les_type, N_geom_data * geom, N_array_3d * status, N_array_3d * start_val, void *data, N_les_callback_3d * callback);
<p>
N_les *#N_assemble_les_2d(int les_type, N_geom_data * geom, N_array_2d * status, N_array_2d * start_val, void *data, N_les_callback_2d * callback);

<p>
templates for callback functions
<p>
N_les_row_entries *#N_callback_template_3d(void *data, N_geom_data * geom, int depth, int row, int col);
<p>
N_les_row_entries *#N_callback_template_2d(void *data, N_geom_data * geom, int row, int col);

\section solvers Available solvers

\subsection direct_solvers Direct solvers

Two direct solvers are implemented, the gauss elimination solver and the lu decomposition solver.
The direct solvers only work with regular quadratic matrices, not with sparse matrices.

<p>
int #N_solver_gauss (N_les * les);

<p>
int #N_solver_lu (N_les * les);


\subsection iterative_solvers Iterative solvers 

The iterative solvers work with regular quadartic and sparse matrices.
<p>
To solve symmetric and positive definite linear equation systems the iterative 
conjugated gradient method is implemented.

int #N_solver_cg(N_les * les, int maxit, double error);

<p>
To solve unsymmetric non definite linear equation system the iterative BiCGSatb method is implemented

<p>
int #N_solver_bicgstab(N_les * les, int maxit, double error);

\section available_pdes Implemented PDE's

Groundwater flow in 2 and 3 dimensions are implemented.

<p>
Groundwater mass balance in three dimension
\verbatim
typedef struct
{
    N_array_3d *phead;          /*!piezometric head */
    N_array_3d *phead_start;    /*!start conditions */
    N_array_3d *kf_x;           /*!x part of the permeability tensor */
    N_array_3d *kf_y;           /*!y part of the permeability tensor */
    N_array_3d *kf_z;           /*!z part of the permeability tensor */
    N_array_3d *q;              /*!sources and sinks */
    N_array_2d *r;              /*!reacharge at the top of the gw leayer */
    N_array_3d *s;              /*!specific yield */
    N_array_3d *nf;             /*!effective porosity */

    N_array_3d *status;         /*!active/inactive/dirichlet cell status */

    double dt;                  /*!calculation time */

} N_gwflow_data3d;
\endverbatim
Groundwater mass balance in two dimension
\verbatim
typedef struct
{
  N_array_2d *phead;		/*!piezometric head */
  N_array_2d *phead_start;	/*!start conditions */
  N_array_2d *kf_x;		/*!x part of the permeability tensor */
  N_array_2d *kf_y;		/*!y part of the permeability tensor */
  N_array_2d *q;		/*!sources and sinks */
  N_array_2d *r;		/*!reacharge at the top of the gw leayer */
  N_array_2d *s;		/*!specific yield */
  N_array_2d *nf;		/*!effective porosity */

  N_array_2d *top;		/*!effective top surface of the aquifer */
  N_array_2d *bottom;		/*!effective bottom of the aquifer */

  N_array_2d *status;		/*!active/inactive/dirichlet cell status */

  double dt;			/*!calculation time */
  int gwtype;			/*!Which type of groundwater, N_GW_CONFINED or N_GW_UNCONFIED */

} N_gwflow_data2d;
\endverbatim

<p>
The groundwater flow calculation callbacks for two and three dimensions
<p>
N_les_row_entries *#N_callback_gwflow_3d(void *gwdata, N_geom_data * geom, int depth, int row, int col);
<p>
N_les_row_entries *#N_callback_gwflow_2d(void *gwdata, N_geom_data * geom, int row, int col);
<p>
Allocating the groundwater flow data arrays
<p>
N_gwflow_data3d *#N_alloc_gwflow_data3d(int depths, int rows, int cols);
<p>
N_gwflow_data2d *#N_alloc_gwflow_data2d(int rows, int cols);
<p>
void #N_free_gwflow_data3d(N_gwflow_data3d * data);
<p>
void #N_free_gwflow_data2d(N_gwflow_data2d * data);

*/
