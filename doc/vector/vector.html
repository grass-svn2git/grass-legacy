<HEAD>
<TITLE>GRASS 5.1 Vector Format and API</TITLE>
</HEAD>
<BODY>
<P>
<H1>GRASS 5.1 Vector Format and API</H1>

This document describes new format for <B>GRASS vector files</B> with 
<B>multicategory</B> and optional <B>3D</B> support.
<P>
You can send any comments to
<A href=mailto:ddgray@armadce.demon.co.uk>David D. Gray</A> and
<A href=mailto:blazek@itc.it>Radim Blazek</A>
<P>
See also:<br>

<A HREF="http://mpa.itc.it/markus/grass51/">Draft GRASS 5.1 Programmer's manual</A>

<HR>

<H4><A HREF="#intro">Introduction</A></H4>
<H4><A HREF="#dir">Directory structure</A></H4>
<H4><A HREF="#coor">coor Format Specification</A></H4>
<H4><A HREF="#head">head Format Specification</A></H4>
<H4><A HREF="#topo">topo Format Specification</A></H4>
<H4><A HREF="#lib">Library</A></H4>
<H4><A HREF="#structures">New or Modified Constants, Structures, Functions</A></H4>
<H4><A HREF="#attr">Attributes</A></H4>
<H4><A HREF="#other">Other informations</A></H4>
<H4><A HREF="v.example.c">Example vector module</A></H4>
<H4><A HREF="v.modules.html">Vector Modules Status</A></H4>
<H4><A HREF="#ascii">Vector ascii Format Specification</A></H4>
<H4><A HREF="#options">Vector modules and options</A></H4>
<HR>

<H2><A NAME="intro">Introduction</A></H2>
<P>
New format is very similar to old GRASS vector format.
<P>
Each element may have none, one or more categories (cats).
More cats are distinguished by field number (field).
Only one cat with cat_num=1 will be used in first stage
and multi-category support on modules level will be added in
future.
<P>
Z-coordinate will be optional and both 2d and 3d files may
be written.


<HR>

<H2><A NAME="dir">Directory structure</A></H2>

Directory structure and file names are a bit changed.
All vector files for one vector map are stored in one
directory:<BR>
<B>$MAPSET/vector/vector_name/</B> <BR>
This directory contains these files:<BR><BR>
<B>coor</B> - binary file, coordinates, former dig/ file<BR>
<B>head</B> - text file, header information, former part of dig/<BR>
<B>topo</B> - binary file, topology, former dig_plus/<BR>
<B>misc</B> - miscellaneous - what's that?<BR>
<B>regi</B> - registration points <BR>

<HR>

<H2><A NAME="coor">coor Format Specification</A></H2>

<H3>Head</H3>
<TABLE border=2>
<TR><TD>Name</TD><TD>Type</TD><TD>Number</TD><TD>Description</TD></TR>

<TR><TD>Version_Major </TD><TD>C</TD><TD>1</TD><TD>&nbsp</TD></TR>
<TR><TD>Version_Minor </TD><TD>C</TD><TD>1</TD><TD>&nbsp</TD></TR>
<TR><TD>Earliest_Major</TD><TD>C</TD><TD>1</TD><TD>&nbsp</TD></TR>
<TR><TD>Earliest_Minor</TD><TD>C</TD><TD>1</TD><TD>&nbsp</TD></TR>

<TR><TD>byte_order</TD><TD>C</TD><TD>1</TD><TD>little or big endian flag;
                  files are written in machine native order but files
		  in both little and big endian order may be read</TD></TR>
<TR><TD>with_z</TD><TD>C</TD><TD>1</TD><TD>2D or 3D flag</TD></TR>
<TR><TD>size</TD><TD>L</TD><TD>1</TD><TD>coor file size</TD></TR>
<TR><TD>reserved</TD><TD>C</TD><TD>10</TD><TD>not used</TD></TR>

</TABLE>

<H3>Body</H3>

The body consists of line records:
<BR>

<TABLE border=2>
<TR><TD>Name</TD><TD>Type</TD><TD>Number</TD><TD>Description</TD></TR>
<TR><TD>record header</TD><TD>I</TD><TD>1</TD><TD>
<UL>
  <LI><B>0. bit</B> : 1 - alive, 0 - dead line
  <LI><B>1. bit</B> : 1 - categories, 0 - no categories
  <LI><B>2.-3. bit</B> : type - one of: GV_POINT, GV_LINE, 
                              GV_BOUNDARY, GV_CENTROID
  <LI><B>4.-7. bit</B> : reserved, not used 
<UL>
</TD></TR>
<TR><TD>ncats</TD><TD>C</TD><TD>1</TD><TD>number of categories 
    (written only if categories exist) </TD></TR>
<TR><TD>field</TD><TD>S</TD><TD>ncats</TD><TD>Category identifier, 
    distinguishes between more categories append to one line 
    (written only if categories exist)</TD></TR>
<TR><TD>cat</TD><TD>I</TD><TD>ncats</TD><TD>category value 
    (written only if categories exist)</TD></TR>
<TR><TD>ncoor</TD><TD>I</TD><TD>1</TD><TD>written for GV_LINES and GV_BOUNDARIES 
    only</TD></TR>
<TR><TD>x</TD><TD>D</TD><TD>ncoor</TD><TD>&nbsp</TD></TR>
<TR><TD>y</TD><TD>D</TD><TD>ncoor</TD><TD>&nbsp</TD></TR>
<TR><TD>z</TD><TD>D</TD><TD>ncoor</TD><TD>present if with_z in head 
    is set to 1</TD></TR>
</TABLE>


<BR>
<B>Types used in coor file</B>
<TABLE border=2>
<TR><TD>Type</TD><TD>Name</TD><TD>Size in Bytes</TD></TR>
<TR><TD>D</TD><TD>Double</TD><TD>8</TD></TR>
<TR><TD>L</TD><TD>Long  </TD><TD>4</TD></TR>
<TR><TD>I</TD><TD>Int   </TD><TD>4</TD></TR>
<TR><TD>S</TD><TD>Short </TD><TD>4</TD></TR>
<TR><TD>C</TD><TD>Char  </TD><TD>1</TD></TR>
</TABLE>

<HR>

<H2><A NAME="head">head file format</A></H2>

The file is unordered list of key/value entries. The <I>key</I>
is a string separated from <I>value</I> by a colon and optional
whitespace. Key words are:<BR>
<PRE>
ORGANIZATION
DIGIT DATE
DIGIT NAME
MAP NAME
MAP DATE
MAP SCALE
OTHER INFO
ZONE
MAP THRESH
</PRE>
<HR>

<H2><A NAME="topo">topo file format</A></H2>

Is not defined yet. 

<HR>

<H2><A NAME="lib">Library</A></H2>

For historical reasons, there are two libraries for vector: <BR><BR>

diglib, dig_*(), DIGLIB, libdig.a, digit library, grass3.x, 4.x<BR>
and<BR>
Vlib, Vect_*(), VECTLIB_REAL, libvect.a, vector library, grass4.x<BR><BR>

Vector library was introduced in grass4.0 to hide vector files' formats
and structures. 
In GRASS 5.1 everything is accessed via Vect_* functions, for example:
<PRE>
    xx = Map.Att[Map.Area[area_num].att].x;
</PRE>by new function<PRE>
    Vect_get_area_centroid()
    Vect_get_centroid_coor()
</PRE>

<P>

<HR>

<H2><A NAME="structures">New or Modified Constants, Structures, Functions</A></H2>
<PRE>
/* types used in memory on run time - may change */
#define GV_POINT      0x01
#define GV_LINE       0x02
#define GV_BOUNDARY   0x04
#define GV_CENTROID   0x08
#define GV_FACE       0x10
#define GV_KERNEL     0x20
#define GV_AREA       0x40
#define GV_VOLUME     0x80

#define GV_POINTS (GV_POINT | GV_CENTROID )
#define GV_LINES (GV_LINE | GV_BOUNDARY )

struct line_cats
  {
      int *field;	/* pointer to array of fields */
      int *cat;		/* pointer to array of categories */
      int n_cats;	/* number of vector categories attached to element */
      int alloc_cats;	/* allocated space */
  };

int Vect_open_new (struct Map_info *, char name *, int with_z);
long Vect_write_line (struct Map_info *, int type, struct line_pnts *, struct line_cats *);
int Vect_read_next_line (struct Map_info *, struct line_pnts *, struct line_cats *);
struct line_cats *Vect_new_cats_struct (void); 
int Vect_reset_cats (struct line_cats *);
int Vect_destroy_cats_struct (struct line_cats *); 
int Vect_cat_set (struct line_cats *, int, int);
int Vect_cat_get (struct line_cats *, int, int *);
int Vect_cat_del (struct line_cats *, int);
int Vect_reset_cats (struct line_cats *);

</PRE>

And many, many others ...

<HR>

<H2><A NAME="attr">Attributes</A></H2>

dig_cats files are not used any more and
vectors' attributes are stored in external database.
Connection with database is done through drivers based on DBMI library
(odbc, dbf, Postgres and MySQL drivers are available at this time). Records in table
are linked to vector entities by field and category number. 
The field identifies table and the category identifies record.
I.e. for unique combination map+mapset+field+category exists one
unique combination driver+database+table+row.
<P>
For each pair <B>map + field</B> must be defined <B>table, key column,
database, driver</B>. This definition must be written to $MAPSET/DB text file.
Each row in DB file contains names separated by spaces in following order
([] - optional): <BR><BR>

<B>map[@mapset] field table [key [database [driver]]] </B><BR><BR>

If key, database or driver are omited (on second and higher row only)
last definition is used. Definition from DB file in other mapset
may be overwritten by definition in current mapset if mapset is specified 
with map name.
<P>
Wild cards <B>*</B> and <B>?</B> may be used in map and mapset names.
<P>
Variables <B>$GISDBASE, $LOCATION, $MAPSET, $MAP, $FIELD</B>
may be used in table, key, database and driver names. Note that
$MAPSET is not current mapset but mapset of the map the rule is defined for.

<P>
<H3>Examples:</H3>
Examples are written mostly for dbf driver where database is full path to
directory with dbf files and table name is name of dbf file without
.dbf extension.
<P>
<PRE><B>* 1 tbl id $GISDBASE/$LOCATION/$MAPSET/vector/$MAP dbf</B></PRE>
This definition says that entities with category of field 1 are linked
to dbf tables with names tbl.dbf saved in vector directories of each map.<BR><BR>

<PRE><B>* 1 $MAP id $GISDBASE/$LOCATION/$MAPSET/dbf dbf</B></PRE> 
Similar as above but all dbf files are in one directory dbf/ in mapset
and names of dbf files are $MAP.dbf<BR><BR>

<PRE><B>water* 1 rivers id /home/grass/dbf dbf</B>
<B>water* 2 lakes lakeid /home/guser/mydb</B>
<B>trans* 1 roads key basedb odbc</B>
<B>trans* 5 rails</B></PRE>
These definitions defines more fields for one map i.e. in one map may be more
features linked to more tables. Definition on first 2 rows are applied for example
on maps water1, water2, ... so that more maps may share one table.<BR><BR>

<PRE><B>water@PERMANENT 1 myrivers id /home/guser/mydbf dbf</B></PRE>
This definion overwrites definition saved in PERMANENT/DB and 
links map from PERMANENT mapset to user's table.<BR><BR>

<P>
Modules should be written so that connections to database for each
vector field are independent. It should be possible to read attributes
of input map from one database and write to some other and even with
some other driver (should not be such problem). 

<P>
There are open questions however. For example how to distinguish when
new table should be written and when not. For example definitions:<BR>
river 1 river id water odbc<BR>
river.backup* 1 NONE<BR>
could be used to say that tables should not be copied for backups of
map river because table is stored in reliable RDBMS. 

<HR>

<H2><A NAME="other">Other Informations</A></H2>
<P>
Bounding box information was moved from coor file to topo file.

<HR>

<H2><A NAME="ascii">Vector ascii Format Specification</A></H2>
<P>
Ascii format in new version contains categories, new type
centroid and z-coordinates. Points and centroids are saved 
as one coordinates pair instead of two. File is saved
in old dig_ascii directory but the name will be probably changed.

<H3>Head</H3>
The head of the file is similar as the head file of vector binary
format but contains bounding box also. Key words are:<BR>
<PRE>
ORGANIZATION
DIGIT DATE
DIGIT NAME
MAP NAME
MAP DATE
MAP SCALE
OTHER INFO
ZONE
WEST EDGE
EAST EDGE
SOUTH EDGE
NORTH EDGE
MAP THRESH
</PRE>

<H3>Body</H3>
The body begins by row:
<PRE>
VERTI:
</PRE>
followed by records of lines:
<PRE>
TYPE NUMBER_OF_COORDINATES [NUMBER_OF_CATEGORIES]
 Y X [Z]
....
 Y X [Z]
[ FIELD CATEGORY]
....
[ FIELD CATEGORY]
</PRE>
Everything in <B>[]</B> is optional. 
TYPE may be:<BR><BR>
<B>P</B> point (dot) <BR> 
<B>p</B> dead point (dead dot) <BR> 
<B>L</B> line  <BR>
<B>l</B> dead line <BR> 
<B>B(A)</B> boundary  <BR>
<B>b(a)</B> dead boundary  <BR>
<B>C</B> centroid  <BR>
<B>c</B> dead centroid  <BR>

<BR>
Example of records:
<PRE>
P 1 1
 1234 3435
 1 354
L 3 1
 4132 4534
 1453 1454
 1453 4543
 1 355
</PRE>

<HR>

<H2><A NAME="options">Vector modules and options</A></H2>

See also grass5/documents/parameter_proposal.txt

<H3>Operation</H3>
Each module which modifies and writes data must read from input= and
write to output= so that data may not be lost. For example v.spag
works on map= at in grass5.0 but if program (system) crashes or treshold was 
specified incorrectly and vector was not backuped, data are lost. 
In this case map= option should be replaced by input= and output=
<P>
Topology is always build by default if coor file was modified.
<P>
Dimension is kept. Input 2D vector is written as 2D, 3D as 3D.

<H3>Options</H3>
<B>-f</B> overwrite existing files, default <BR>
<B>-i</B> ask user before overwriting existing files <BR>
<B>-b</B> do not build topo file; topo file is written by default <BR>
<B>-q</B> quiet <BR>
<B>-v</B> run verbosely <BR>
<B>-t</B> create new table, default ??? <BR>
<B>-u</B> don't create new table ??? <BR>
<B>-z</B> write 3D file (if input was 2D) <BR>
<BR>
<B>map=</B> input vector for modules without output <BR>
<B>input=</B> input vector <BR>
<B>output=</B> output vector <BR>
<B>type=</B>  type of elements:  point,line,boundary,centroid,area <BR>
<B>cat=</B> category or category list (example: 1,5,9-13,35) <BR>
<B>field=</B> field number <BR>
<B>where=</B> condition of SQL statement for selection of records <BR>
<B>col=</B> column name (in external table) <BR>

</BODY>
</HTML>

